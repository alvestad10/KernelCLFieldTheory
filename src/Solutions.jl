export getSolutions


function getSolutions(model::ScalarTheory{D}) where {D}
    @unpack n_steps = model
    @unpack t_steps = model.contour

    solution = Dict{String, Any}(
        "phiRe" => 0.0,
        "phiRe_err" => 0.0,
        "phiIm" => 0.0,
        "phiIm_err" => 0.0,
        "phi2Im" => 0.0,
        "phi2Im_err" => 0.0
    )

    if (D == 1 && model.m == 1.0 && model.λ == 1.0 && model.contour.β == 0.4 && model.as*model.n_steps == 1.6)
        solution["phi2Re"] = 0.958
        solution["phi2Re_err"] = 0.005

        # TODO:
        # Eucledian data from HMC

        
        thimble_tp = collect(0.0:0.2:1.6)

        yRe_J0 = [0.7500000000000002, 0.7153179190751446, 0.6329479768786128, 0.5115606936416188, 0.34682080924855496, 0.16473988439306364, -0.03468208092485492, -0.24277456647398798, -0.43352601156069337]
        yerrRe_J0 = abs.(yRe_J0 .- [0.8063583815028901, 0.7760115606936415, 0.6936416184971097, 0.5635838150289016, 0.4118497109826589, 0.22976878612716756, 0.013005780346823315, -0.18208092485548866, -0.36849710982658657])
        yIm_J0 = [0.018461538461538418, -0.04153846153846155, -0.0953846153846154, -0.13923076923076924, -0.17153846153846153, -0.19230769230769235, -0.19846153846153847, -0.19230769230769235, -0.17230769230769233]
        yerrIm_J0 = abs.(yIm_J0 .- [0.03230769230769236, -0.0284615384615384, -0.08307692307692302, -0.12692307692307686, -0.15846153846153838, -0.17999999999999994, -0.18615384615384611, -0.18076923076923074, -0.16076923076923072])
        
        solution["thimble_J0"] = Dict{String,Vector{Float64}}(
            "tp" => thimble_tp,
            "corr0tRe" => yRe_J0,
            "corr0tIm" => yIm_J0,
            "corr0tRe_err" => yerrRe_J0,
            "corr0tIm_err" => yerrIm_J0
            )


        yRe_grady = [0.8185970564310932, 0.7561636233225546, 0.6317573659345812, 0.45066536838688753, 0.22727890175147558, -0.017631293885396415, -0.2678535508352673, -0.5168455235965776, -0.7459122218615888]
        yerrRe_grady = abs.(yRe_grady .- [0.8924050632911394, 0.8227848101265826, 0.7025316455696204, 0.518987341772152, 0.2974683544303798, 0.05063291139240533, -0.1898734177215189, -0.42405063291139244, -0.6265822784810124])
        yIm_grady = [0.03720930232558142, -0.024418604651162773, -0.0825581395348837, -0.1337209302325581, -0.1767441860465116, -0.2081395348837209, -0.21627906976744188, -0.213953488372093, -0.21162790697674416]
        yerrIm_grady = abs.(yIm_grady .- [0.008139534883720961, -0.055813953488372064, -0.1127906976744186, -0.16162790697674417, -0.20232558139534879, -0.23139534883720925, -0.23953488372093024, -0.23720930232558135, -0.23488372093023252])
            
        solution["thimble_grady"] = Dict{String,Vector{Float64}}(
            "tp" => thimble_tp,
            "corr0tRe" => yRe_grady,
            "corr0tIm" => yIm_grady,
            "corr0tRe_err" => yerrRe_grady,
            "corr0tIm_err" => yerrIm_grady
            )
    end

    if (D == 2 && model.m == 1.0 && model.λ == 1.0 && model.contour.β == 0.4 && model.as*model.n_steps == 1.6 && model.as == 0.2)
        solution["phi2Re"] = 0.5366
        solution["phi2Re_err"] = 0.001
    end

    if (D == 2 && model.m == 1.0 && model.λ == 1.0 && model.contour.β == 0.4 && model.as*model.n_steps == 1.6 && model.as == 0.1)
        solution["phi2Re"] = 0.4072
        solution["phi2Re_err"] = 0.005
    end

    return solution
end